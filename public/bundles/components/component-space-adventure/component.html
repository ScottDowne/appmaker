<polymer-element name="ceci-space-adventure" extends="ceci-element" attributes="playerMoveSpeed playerProjectileSpeed enemyProjectileSpeed playerProjectileRate enemyProjectileRate enemyMoveSpeed" playerProjectileSpeed="0.75" enemyProjectileSpeed="0.75" playerMoveSpeed="0.75" enemyMoveSpeed="0.75"  playerProjectileRate="1" enemyProjectileRate="1">
  <ceci-definition>
    {
      "name": "Space Adventure",
      "thumbnail": "",
      "description": "",
      "broadcasts": {
        "playerHit": {
          "label": "",
          "description": "A player was hit by an enemy projectile.",
          "labe": "Player Hit"
        },
        "enemyHit": {
          "label": "",
          "description": "An enemy was hit by a player projectile.",
          "labe": "Enemy Hit"
        }
      },
      "listeners": {
        "playerActionStart": {
          "description": "Move player right or left",
          "label": "Player Action Start"
        },
        "playerActionStop": {
          "description": "Stop player movement.",
          "label": "Player Action Stop"
        },
        "createEnemy": {
          "description": "Adds an enemy ship to the game.",
          "label": "Create Enemy"
        },
        "createPlayer": {
          "description": "Adds a player ship to the game.",
          "label": "Create Player"
        },
        "killPlayer": {
          "description": "Removes a player ship from the game.",
          "label": "Kill Player"
        },
        "killEnemy": {
          "description": "Removes an enemy ship from the game.",
          "label": "Kill Enemy"
        }
      },
      "attributes": {
        "playerMoveSpeed": {
          "description": "",
          "label": "Player Move Speed",
          "editable": "select",
          "options": {"Fastest": "0.25", "Fast": "0.5", "Normal": "0.75", "Slow": "1", "Slowest": "1.25"}
        },
        "enemyMoveSpeed": {
          "description": "",
          "label": "Enemy Move Speed",
          "editable": "select",
          "options": {"Fastest": "0.25", "Fast": "0.5", "Normal": "0.75", "Slow": "1", "Slowest": "1.25"}
        },
        "playerProjectileSpeed": {
          "description": "",
          "label": "Player Projectile Speed",
          "editable": "select",
          "options": {"Fastest": "0.25", "Fast": "0.5", "Normal": "0.75", "Slow": "1", "Slowest": "1.25"}
        },
        "enemyProjectileSpeed": {
          "description": "",
          "label": "Enemy Projectile Speed",
          "editable": "select",
          "options": {"Fastest": "0.25", "Fast": "0.5", "Normal": "0.75", "Slow": "1", "Slowest": "1.25"}
        },
        "playerProjectileRate": {
          "description": "",
          "label": "Player Projectile Rate",
          "editable": "number",
          "step" : ".1"
        },
        "enemyProjectileRate": {
          "description": "",
          "label": "Enemy Projectile Rate",
          "editable": "number",
          "step" : ".1"
        }
      }
    }
  </ceci-definition>
  <template>
    <link rel="stylesheet" href="component.css"></link>
    <div class="game-board"></div>
    <shadow></shadow>
  </template>
    <script>
      Polymer("ceci-space-adventure", {
        playerAlive: false,
        ready: function() {
          this.super();
          window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                         window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
          this.player = {
            position: {
              left: 0,
              top: 278
            },
            speed: (this.playerMoveSpeed-0)/100
          };

          this.enemies = {
            all: [],
            speed: (this.enemyMoveSpeed-0)/100
          };

          this.playerProjectiles = {
            all: [],
            speed: (this.playerProjectileSpeed-0)/100
          };

          this.enemyProjectiles = {
            all: [],
            speed: (this.enemyProjectileSpeed-0)/100
          };
        },
        attached: function() {
          this.super();

          var diff;
          var step;
          var newLeft;
          var that = this;
          var width = 310 - 16;
          var timestamp;
          this.fireTimestamp;

          function updatePlayer() {
            diff = (Date.now()/1000) - timeStamp;
            step = diff / that.player.speed;
            if (that.playerMovingLeft) {
              newLeft = that.player.position.left-step;
              if (newLeft<0) {
                newLeft = 0;
              }
            } else {
              newLeft = that.player.position.left+step;
              if (newLeft>width) {
                newLeft = width;
              }
            }
            that.player.position.left = newLeft;
            that.player.element.style.transform = "translate(" + newLeft + "px, 278px)";
          }

          function updatePlayerProjectile(projectile, index) {
            newTop = projectile.top-step;
            if (newTop > 0) {
              projectile.top = newTop;
              projectile.element.style.transform = "translate(" + projectile.left + "px, " + projectile.top + "px)";

              if (!projectile.hitSomething && projectile.top >= 32) {
                that.enemies.all.forEach(function(enemy, index) {
                  if (enemy.alive && (projectile.left + 16) >= enemy.left && projectile.left <= (enemy.left + 16)) {
                    that.broadcast("enemyHit", index.toString());
                    projectile.hitSomething = true;
                  }
                });
              }

            } else {
              that.shadowRoot.querySelector(".game-board").removeChild(projectile.element);
              that.playerProjectiles.all.splice(index, 1);
            }
          }

          function updatePlayerProjectiles() {
            diff = Date.now()/1000 - timeStamp;
            step = diff / that.playerProjectiles.speed;
            that.playerProjectiles.all.forEach(updatePlayerProjectile);
          }

          function updateEnemyProjectile(projectile, index) {
// garbage collection no no
            newTop = projectile.top+step;
            if (newTop < 295) {
              projectile.top = newTop;
              projectile.element.style.transform = "translate(" + projectile.left + "px, " + projectile.top + "px)";
              if (that.playerAlive && !projectile.hitSomething && projectile.top >= 263) {
                if ((projectile.left + 16) >= that.player.position.left && projectile.left <= (that.player.position.left + 16) ) {
                  projectile.hitSomething = true;
                  that.broadcast("playerHit");
                }
              }
            } else {
              that.shadowRoot.querySelector(".game-board").removeChild(projectile.element);
              that.enemyProjectiles.all.splice(index, 1);
            }
          }

          function updateEnemyProjectiles() {
            diff = Date.now()/1000 - timeStamp;
            step = diff / that.enemyProjectiles.speed;
            that.enemyProjectiles.all.forEach(updateEnemyProjectile);
          }

          function createEnemyProjectile(enemy) {
            var projectileElement = document.createElement("div");
            projectileElement.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVQ4jWNgYGD4TyEeNWCYGPD/PyrGpRiHOpgADBAyAEMd1QygxAtLUTFOA7CrY/j/Hw3jNAC7OlRJQtGGRR1lBgAABrNj2GoxiV8AAAAASUVORK5CYII=)";
            var left = enemy.left;
            var top = 16;
            var projectile = {
              element: projectileElement,
              left: left,
              top: top,
              hitSomething: false
            };
            that.enemyProjectiles.all.push(projectile);
            projectileElement.style.transform = "translate(" + left + "px, " + top + "px)";
            projectileElement.classList.add("sprite");
            that.shadowRoot.querySelector(".game-board").appendChild(projectileElement);
          }

          function createPlayerProjectile() {
            var projectileElement = document.createElement("div");
            projectileElement.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVQ4jWNgYGD4TyEeNWCYGPD/PyrGpRiHOpgADBAyAEMd1QygxAtLUTFOA7CrY/j/Hw3jNAC7OlRJQtGGRR1lBgAABrNj2GoxiV8AAAAASUVORK5CYII=)";
            var left = that.player.position.left;
            var top = that.player.position.top;
            var projectile = {
              element: projectileElement,
              left: left,
              top: top,
              hitSomething: false
            };
            that.playerProjectiles.all.push(projectile);
            projectileElement.style.transform = "translate(" + left + "px, " + top + "px)";
            projectileElement.classList.add("sprite");
            that.shadowRoot.querySelector(".game-board").appendChild(projectileElement);
          }

          function playerFire() {
            diff = (Date.now()/1000) - that.fireTimestamp;
            if (diff >= that.playerProjectileRate-0) {
              createPlayerProjectile();
// want the timer ticking even if fire is not being held, that way a fresh click fires, but holding it down or rapid fire still lock to the fire rate
              that.fireTimestamp = Date.now()/1000;
            }
          }

          function enemyFire(enemy) {
            diff = (Date.now()/1000) - enemy.fireTimestamp;
            if (diff >= that.enemyProjectileRate-0) {
              createEnemyProjectile(enemy);
// want the timer ticking even if fire is not being held, that way a fresh click fires, but holding it down or rapid fire still lock to the fire rate
              enemy.fireTimestamp = Date.now()/1000;
            }
          }

          function enemiesFire() {
            that.enemies.all.forEach(enemyFire);
          }

          function updateEnemies() {
            diff = Date.now()/1000 - timeStamp;
            step = diff / that.enemies.speed;
            that.enemies.all.forEach(updateEnemy);
          }

          function updateEnemy(enemy) {
            if (enemy.movingLeft) {
              newLeft = enemy.left-step;
              if (newLeft<0) {
                newLeft = newLeft * -1;
                enemy.movingLeft = false;
              }
            } else {
              newLeft = enemy.left+step;
              if (newLeft>width) {
                newLeft = newLeft - (newLeft - width);
                enemy.movingLeft = true;
              }
            }
            enemy.left = newLeft;
            enemy.element.style.transform = "translate(" + newLeft + "px, 16px)";
          }

          this.updatePlayer = updatePlayer;
          this.updateEnemy = updateEnemy;
          this.updateEnemies = updateEnemies;
          this.playerFire = playerFire;
          this.enemiesFire = enemiesFire;

          function update() {
            if (Date.now()/1000 - timeStamp > 1) {
              timeStamp = Date.now()/1000;
            }
            if (that.playerMovingRight || that.playerMovingLeft) {
              updatePlayer();
            }
            if (that.playerFiring) {
              playerFire();
            }
            enemiesFire();
            updatePlayerProjectiles();
            updateEnemyProjectiles();
            updateEnemies();
            timeStamp = Date.now()/1000;
            window.requestAnimationFrame(update);
          }
          timeStamp = Date.now()/1000;
          update();
        },
        playerMoveSpeedChanged: function() {
          this.player.speed = (this.playerMoveSpeed-0)/100;
        },
        enemyMoveSpeedChanged: function() {
          this.enemies.speed = (this.enemyMoveSpeed-0)/100;
        },
        enemyProjectileSpeedChanged: function() {
          this.enemyProjectiles.speed = (this.enemyProjectileSpeed-0)/100;
        },
        playerProjectileSpeedChanged: function() {
          this.playerProjectiles.speed = (this.playerProjectileSpeed-0)/100;
        },
        playerAnimateProjectile: function() {
          var playerProjectile = document.createElement("div");
          var that = this;
          var hitSomething = false;
          playerProjectile.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVQ4jWNgYGD4TyEeNWCYGPD/PyrGpRiHOpgADBAyAEMd1QygxAtLUTFOA7CrY/j/Hw3jNAC7OlRJQtGGRR1lBgAABrNj2GoxiV8AAAAASUVORK5CYII=)";
          var left = that.player.position.left;
          var top = that.player.position.top;
          playerProjectile.style.transform = "translate(" + left + "px, " + top + "px)";
          playerProjectile.classList.add("sprite");
          this.shadowRoot.querySelector(".game-board").appendChild(playerProjectile);
          function animateProjectile() {
            /*if (top > 0) {
              top += playerProjectile.offsetTop - that.playerProjectileSpeed;
              playerProjectile.style.transform = "translate(" + left + "px, " + top + "px)";

              // Need these to update on a timer, and not based on the animation frame speed.
              window.requestAnimationFrame(animateProjectile);
              if (!hitSomething && top >= 32) {
                for (var i = 0; i < that.enemies.length; i++) {
                  if (that.enemies[i].alive && (left + 16) >= that.enemies[i].left && left <= (that.enemies[i].left + 16)) {
                    that.broadcast("enemyHit", i.toString());
                    hitSomething = true;
                    break;
                  }
                }
              }
            } else {
              that.shadowRoot.querySelector(".game-board").removeChild(playerProjectile);
            }*/
          }
          animateProjectile();
        },
        /*playerFire: function() {
          this.playerFiring = true;
          var timeStamp = 0;
          var that = this;
          function fireProjectile() {
            if (that.playerFiring) {
              var diff = Date.now()/1000 - timeStamp;
              if (timstamp = 0 || diff >= that.playerProjectileRate-0) {
                that.playerAnimateProjectile();
                timeStamp = Date.now()/1000;
              }

              window.requestAnimationFrame(fireProjectile);
            }
          }
          fireProjectile();
        },*/
        createPlayer: function() {
          var player = document.createElement("div");
          player.classList.add("player");
          player.classList.add("sprite");
          player.style.transform = "translate(0px, 278px)";
          this.player.element = player;
          this.shadowRoot.querySelector(".game-board").appendChild(player);
          this.playerAlive = true;
        },
        playerActionStart: function(dir) {
          if (!this.playerAlive) {
            return;
          }
          if (dir === "a" || dir === "b") {
            this.playerFiring = true;
            this.fireTimestamp = Date.now()/1000;
            this.playerFire();
            return;
          }

          if (dir === "left") {
            this.playerMovingLeft = true;
            this.playerMovingRight = false;
            this.updatePlayer();
          } else {
            this.playerMovingLeft = false;
            this.playerMovingRight = true;
            this.updatePlayer();
          }
        },
        playerActionStop: function() {
          var that = this;
          that.playerMovingLeft = false;
          that.playerMovingRight = false;
          that.playerFiring = false;
        },
        killPlayer: function() {
          this.playerAlive = false;
          var player = this.shadowRoot.querySelector(".player");
          this.player.position.left = 0;
          if (player) {
            this.shadowRoot.querySelector(".game-board").removeChild(player);
          }
        },
        killEnemy: function(value) {
          var enemy = this.enemies.all[value];
          if (!enemy) {
            return;
          }
          enemy.alive = false;
          
          this.shadowRoot.querySelector(".game-board").removeChild(enemy.element);
          this.enemies.all.splice(value, 1);
        },
        createEnemy: function() {
          var that = this;
          var enemyElement = document.createElement("div");
          var enemy = {
            element: enemyElement,
            left: 0,
            movingLeft: false,
            alive: true,
            fireTimestamp: Date.now()/1000
          };
          enemyElement.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVQ4jc2TwQ3AMAgD2X+X7tMJuob7aSJw7LZSHsnDnwAng5WICExqB8BxXl25iEf5TfRqAEi/Aa0AVLm+cGTlwKyq7THA3WlIoQNoBTOsY+ThfIdPQLHfhtMar4CSAANQewaAojvrNoV1f2FGN8g2pF6X9BjjAAAAAElFTkSuQmCC)";
          enemyElement.classList.add("sprite");
          this.shadowRoot.querySelector(".game-board").appendChild(enemyElement);
          this.enemies.all.push(enemy);
          //this.updateEnemy(enemy);
          /*var timeStamp = 0;
          function animateEnemyProjectile() {
            var enemyProjectile = document.createElement("div");
            enemyProjectile.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVQ4jWNgYGD4TyEeNWCYGPD/PyrGpRiHOpgADBAyAEMd1QygxAtLUTFOA7CrY/j/Hw3jNAC7OlRJQtGGRR1lBgAABrNj2GoxiV8AAAAASUVORK5CYII=)";
            var left = enemy.left;
            var top = 16;
            var hitSomething = false;
            enemyProjectile.style.transform = "translate(" + left + "px, " + top + "px)";
            enemyProjectile.classList.add("sprite");
            that.shadowRoot.querySelector(".game-board").appendChild(enemyProjectile);
            function animateProjectile() {
              // Need these to update on a timer, and not based on the animation frame speed.
              if (top < 295) {
                // this speed thing is so rubbish
                top += (that.enemyProjectileSpeed-0);
                enemyProjectile.style.transform = "translate(" + left + "px, " + top + "px)";
                window.requestAnimationFrame(animateProjectile);
                if (that.playerAlive && !hitSomething && top >= 263) {
                  if ((left + 16) >= that.player.position.left && left <= (that.player.position.left + 16) ) {
                    hitSomething = true;
                    that.broadcast("playerHit");
                  }
                }
              } else {
                that.shadowRoot.querySelector(".game-board").removeChild(enemyProjectile);
              }
            }
            animateProjectile();
          }
          function fireProjectile() {
            if (enemy.alive) {
              var diff = Date.now()/1000 - timeStamp;
              if (timstamp = 0 || diff >= that.enemyProjectileRate-0) {
                animateEnemyProjectile();
                timeStamp = Date.now()/1000;
              }

              window.requestAnimationFrame(fireProjectile);
            }
          }
          function enemyAI() {
            if (enemy.alive) {
              if (enemy.direction === "right") {
                if (enemy.left + 1 === 295) {
                  enemy.direction = "left";
                }
                enemy.left++;
                enemyElement.style.transform = "translate(" + enemy.left + "px, 16px)";
              } else {
                if (enemy.left - 1 === 0) {
                  enemy.direction = "right";
                }
                enemy.left--;
                enemyElement.style.transform = "translate(" + enemy.left + "px, 16px)";
              }
              // Need these to update on a timer, and not based on the animation frame speed.
              window.requestAnimationFrame(enemyAI);
            }
          }*/
          //enemyAI();
          //fireProjectile();
        }
      });
    </script>
</polymer-element>
