<polymer-element name="ceci-space-adventure" extends="ceci-element" attributes="playerMoveSpeed playerProjectileSpeed enemyProjectileSpeed playerProjectileRate enemyProjectileRate" playerProjectileSpeed="1" enemyProjectileSpeed="1" playerMoveSpeed="1" playerProjectileRate="1" enemyProjectileRate="1">
  <ceci-definition>
    {
      "name": "Space Adventure",
      "thumbnail": "",
      "description": "",
      "broadcasts": {
        "playerHit": {
          "label": "",
          "description": "A player was hit by an enemy projectile.",
          "labe": "Player Hit"
        },
        "enemyHit": {
          "label": "",
          "description": "An enemy was hit by a player projectile.",
          "labe": "Enemy Hit"
        }
      },
      "listeners": {
        "playerActionStart": {
          "description": "Move player right or left",
          "label": "Player Action Start"
        },
        "playerActionStop": {
          "description": "Stop player movement.",
          "label": "Player Action Stop"
        },
        "createEnemy": {
          "description": "Adds an enemy ship to the game.",
          "label": "Create Enemy"
        },
        "createPlayer": {
          "description": "Adds a player ship to the game.",
          "label": "Create Player"
        },
        "killPlayer": {
          "description": "Removes a player ship from the game.",
          "label": "Kill Player"
        },
        "killEnemy": {
          "description": "Removes an enemy ship from the game.",
          "label": "Kill Enemy"
        }
      },
      "attributes": {
        "playerMoveSpeed": {
          "description": "",
          "label": "Player Move Speed",
          "editable": "number",
          "step" : ".1"
        },
        "playerProjectileSpeed": {
          "description": "",
          "label": "Player Projectile Speed",
          "editable": "number",
          "step" : ".1"
        },
        "enemyProjectileSpeed": {
          "description": "",
          "label": "Enemy Projectile Speed",
          "editable": "number",
          "step" : ".1"
        },
        "playerProjectileRate": {
          "description": "",
          "label": "Player Projectile Rate",
          "editable": "number",
          "step" : ".1"
        },
        "enemyProjectileRate": {
          "description": "",
          "label": "Enemy Projectile Rate",
          "editable": "number",
          "step" : ".1"
        }
      }
    }
  </ceci-definition>
  <template>
    <link rel="stylesheet" href="component.css"></link>
    <div class="game-board"></div>
    <shadow></shadow>
  </template>
    <script>
      Polymer("ceci-space-adventure", {
        enemies: [],
        playerAlive: false,
        ready: function() {
          this.super();
          window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                         window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
          this.playerPosition = 0;
          this.playerMoving = false;
        },
        playerAnimateProjectile: function() {
          var playerProjectile = document.createElement("div");
          var that = this;
          var hitSomething = false;
          playerProjectile.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVQ4jWNgYGD4TyEeNWCYGPD/PyrGpRiHOpgADBAyAEMd1QygxAtLUTFOA7CrY/j/Hw3jNAC7OlRJQtGGRR1lBgAABrNj2GoxiV8AAAAASUVORK5CYII=)";
          var left = that.playerPosition;
          var top = 278;
          playerProjectile.style.transform = "translate(" + left + "px, " + top + "px)";
          playerProjectile.classList.add("sprite");
          this.shadowRoot.querySelector(".game-board").appendChild(playerProjectile);
          function animateProjectile() {
            if (top > 0) {
              top += playerProjectile.offsetTop - that.playerProjectileSpeed;
              playerProjectile.style.transform = "translate(" + left + "px, " + top + "px)";

              // Need these to update on a timer, and not based on the animation frame speed.
              window.requestAnimationFrame(animateProjectile);
              if (!hitSomething && top >= 32) {
                for (var i = 0; i < that.enemies.length; i++) {
                  if (that.enemies[i].alive && (left + 16) >= that.enemies[i].left && left <= (that.enemies[i].left + 16)) {
                    that.broadcast("enemyHit", i.toString());
                    hitSomething = true;
                    break;
                  }
                }
              }
            } else {
              that.shadowRoot.querySelector(".game-board").removeChild(playerProjectile);
            }
          }
          animateProjectile();
        },
        playerFire: function() {
          this.playerFiring = true;
          var timeStamp = 0;
          var that = this;
          function fireProjectile() {
            if (that.playerFiring) {
              var diff = Date.now()/1000 - timeStamp;
              if (timstamp = 0 || diff >= that.playerProjectileRate-0) {
                that.playerAnimateProjectile();
                timeStamp = Date.now()/1000;
              }

              window.requestAnimationFrame(fireProjectile);
            }
          }
          fireProjectile();
        },
        createPlayer: function() {
          var player = document.createElement("div");
          player.classList.add("player");
          player.classList.add("sprite");
          player.style.transform = "translate(0px, 278px)";
          this.shadowRoot.querySelector(".game-board").appendChild(player);
          this.playerAlive = true;
        },
        playerActionStart: function(dir) {
          if (!this.playerAlive) {
            return;
          }
          var player = this.shadowRoot.querySelector(".player");
          var that = this;
          if (dir === "a" || dir === "b") {
            this.playerFire();
            return;
          }
          if (dir === "left") {
            this.playerMovingLeft = true;
            this.playerMovingRight = false;
            function moveLeft() {
              if (that.playerMovingLeft && that.playerPosition>0) {
                that.playerPosition-=(that.playerMoveSpeed-0);
                player.style.transform = "translate(" + that.playerPosition + "px, 278px)";
                // Need these to update on a timer, and not based on the animation frame speed.
                window.requestAnimationFrame(moveLeft);
              }
            }
            moveLeft();
          } else {
            this.playerMovingLeft = false;
            this.playerMovingRight = true;
            function moveRight() {
              if (that.playerMovingRight && that.playerPosition<295) {
                that.playerPosition+=(that.playerMoveSpeed-0);
                player.style.transform = "translate(" + that.playerPosition + "px, 278px)";
                // Need these to update on a timer, and not based on the animation frame speed.
                window.requestAnimationFrame(moveRight);
              }
            }
            moveRight();
          }
        },
        playerActionStop: function() {
          this.playerMovingLeft = false;
          this.playerMovingRight = false;
          this.playerFiring = false;
        },
        killPlayer: function() {
          this.playerAlive = false;
          var player = this.shadowRoot.querySelector(".player");
          this.playerPosition = 0;
          if (player) {
            this.shadowRoot.querySelector(".game-board").removeChild(player);
          }
        },
        killEnemy: function(value) {
          var enemy = this.enemies[value];
          if (!enemy) {
            return;
          }
          enemy.alive = false;
          
          this.shadowRoot.querySelector(".game-board").removeChild(enemy.element);
          this.enemies.splice(value, 1);
        },
        createEnemy: function() {
          var that = this;
          var enemyElement = document.createElement("div");
          var enemy = {
            element: enemyElement,
            alive: true,
            left: 0
          };
          var direction = "right";
          enemyElement.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVQ4jc2TwQ3AMAgD2X+X7tMJuob7aSJw7LZSHsnDnwAng5WICExqB8BxXl25iEf5TfRqAEi/Aa0AVLm+cGTlwKyq7THA3WlIoQNoBTOsY+ThfIdPQLHfhtMar4CSAANQewaAojvrNoV1f2FGN8g2pF6X9BjjAAAAAElFTkSuQmCC)";
          enemyElement.classList.add("sprite");
          this.shadowRoot.querySelector(".game-board").appendChild(enemyElement);
          this.enemies.push(enemy);
          var timeStamp = 0;
          function animateEnemyProjectile() {
            var enemyProjectile = document.createElement("div");
            enemyProjectile.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVQ4jWNgYGD4TyEeNWCYGPD/PyrGpRiHOpgADBAyAEMd1QygxAtLUTFOA7CrY/j/Hw3jNAC7OlRJQtGGRR1lBgAABrNj2GoxiV8AAAAASUVORK5CYII=)";
            var left = enemy.left;
            var top = 16;
            var hitSomething = false;
            enemyProjectile.style.transform = "translate(" + left + "px, " + top + "px)";
            enemyProjectile.classList.add("sprite");
            that.shadowRoot.querySelector(".game-board").appendChild(enemyProjectile);
            function animateProjectile() {
              // Need these to update on a timer, and not based on the animation frame speed.
              if (top < 295) {
                // this speed thing is so rubbish
                top += (that.enemyProjectileSpeed-0);
                enemyProjectile.style.transform = "translate(" + left + "px, " + top + "px)";
                window.requestAnimationFrame(animateProjectile);
                if (!hitSomething && top >= 263) {
                  if ((left + 16) >= that.playerPosition && left <= (that.playerPosition + 16) ) {
                    hitSomething = true;
                    that.broadcast("playerHit");
                  }
                }
              } else {
                that.shadowRoot.querySelector(".game-board").removeChild(enemyProjectile);
              }
            }
            animateProjectile();
          }
          function fireProjectile() {
            if (enemy.alive) {
              var diff = Date.now()/1000 - timeStamp;
              if (timstamp = 0 || diff >= that.enemyProjectileRate-0) {
                animateEnemyProjectile();
                timeStamp = Date.now()/1000;
              }

              window.requestAnimationFrame(fireProjectile);
            }
          }
          function enemyAI() {
            if (enemy.alive) {
              if (direction === "right") {
                if (enemy.left + 1 === 295) {
                  direction = "left";
                }
                enemy.left++;
                enemyElement.style.transform = "translate(" + enemy.left + "px, 16px)";
              } else {
                if (enemy.left - 1 === 0) {
                  direction = "right";
                }
                enemy.left--;
                enemyElement.style.transform = "translate(" + enemy.left + "px, 16px)";
              }
              // Need these to update on a timer, and not based on the animation frame speed.
              window.requestAnimationFrame(enemyAI);
            }
          }
          enemyAI();
          fireProjectile();
        }
      });
    </script>
</polymer-element>
